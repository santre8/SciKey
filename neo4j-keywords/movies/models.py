from django.db import models
# from neomodel import ArrayProperty, StringProperty, IntegerProperty, RelationshipFrom, RelationshipTo, StructuredRel, UniqueIdProperty
from django_neomodel import DjangoNode
from neomodel import (
    StringProperty, IntegerProperty, FloatProperty, DateTimeProperty, ArrayProperty,
    RelationshipTo, RelationshipFrom, StructuredRel,UniqueIdProperty
)
# MATCH (d:Document {id: "1006198"})-[:CONTAINS_KEYWORD]->(k:Keyword)-[:MAPS_TO]->(i:Item)
# MATCH path = (i)-[:SUBCLASS_OF*]->(ancestor)
# RETURN path
class ActedIn(StructuredRel):
    roles = ArrayProperty(StringProperty())


class Movie(DjangoNode):
    uuid = UniqueIdProperty(primary_key=True)
    title = StringProperty()
    tagline = StringProperty()
    released = IntegerProperty()

    directors = RelationshipFrom('Person', 'DIRECTED')
    writters = RelationshipFrom('Person', 'WROTE')
    producers = RelationshipFrom('Person', 'PRODUCED')
    reviewers = RelationshipFrom('Person', 'REVIEWED')
    actors = RelationshipFrom('Person', 'ACTED_IN', model=ActedIn)

    class Meta:
        app_label = 'movies'


class Person(DjangoNode):
    uuid = UniqueIdProperty(primary_key=True)
    name = StringProperty()
    born = IntegerProperty()

    follows = RelationshipTo('Person', 'FOLLOWS')
    directed = RelationshipFrom('Movie', 'DIRECTED')
    wrote = RelationshipFrom('Movie', 'WROTE')
    produced = RelationshipFrom('Movie', 'PRODUCED')
    reviewed = RelationshipFrom('Movie', 'REVIEWED')
    acted_in = RelationshipFrom('Movie', 'ACTED_IN')

    class Meta:
        app_label = 'movies'



# ---------- Relationship models (optional properties) ----------
# ---------------- Relationship models ----------------

class ContainsKeyword(StructuredRel):
    positions   = ArrayProperty(IntegerProperty(), default=[])  # token offsets
    count       = IntegerProperty(default=1)                    # frequency in doc
    provenance  = StringProperty()                              # was: source (reserved)


class MapsTo(StructuredRel):
    confidence  = FloatProperty()           # 0..1
    provenance  = StringProperty()          # was: source (reserved)


class SubclassOf(StructuredRel):
    depth       = IntegerProperty()         # 1 for direct, n for step index
    provenance  = StringProperty()          # was: source (reserved)


class InstanceOf(StructuredRel):
    provenance  = StringProperty()          # was: source (reserved)
    note        = StringProperty()


# ---------------- Node models ----------------

class Document(DjangoNode):
    # stable external id
      # optional app-level stable uid (generated by neomodel)
    uid = UniqueIdProperty()                      

    # maps Python attr 'docid' -> Neo4j property 'id'
    docid = StringProperty(required=True, unique_index=True, db_property='id')

    # optional extras

    # Document -> Keyword
    keywords = RelationshipTo('Keyword', 'CONTAINS_KEYWORD', model=ContainsKeyword)

    class Meta:
        app_label = 'movies'

    def __str__(self):
        return self.docid


class Keyword(DjangoNode):
    name = StringProperty(unique_index=True, required=True)

    # back-link
    documents = RelationshipFrom('Document', 'CONTAINS_KEYWORD', model=ContainsKeyword)

    # Keyword -> Item
    maps_to = RelationshipTo('Item', 'MAPS_TO', model=MapsTo)

    class Meta:
        app_label = 'movies'

    def __str__(self):
        return self.name


class Item(DjangoNode):
    qid   = StringProperty(unique_index=True, required=True)  # e.g., Q2334061
    label = StringProperty()

    # Item -> Item (P279)
    ancestors   = RelationshipTo('Item', 'SUBCLASS_OF', model=SubclassOf)
    descendants = RelationshipFrom('Item', 'SUBCLASS_OF', model=SubclassOf)

    # Item -> Class (P31)
    instance_of = RelationshipTo('Class', 'INSTANCE_OF', model=InstanceOf)

    # reverse from Keyword
    mapped_from = RelationshipFrom('Keyword', 'MAPS_TO', model=MapsTo)

    class Meta:
        app_label = 'movies'

    def __str__(self):
        return f"{self.qid} ({self.label})" if self.label else self.qid


class Class(DjangoNode):
    qid   = StringProperty(unique_index=True, required=True)
    label = StringProperty()

    members = RelationshipFrom('Item', 'INSTANCE_OF', model=InstanceOf)

    class Meta:
        app_label = 'movies'

    def __str__(self):
        return f"{self.qid} ({self.label})" if self.label else self.qid